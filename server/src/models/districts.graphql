type Query {
  district(id: ID!): [District!]
  districts: [District!]
  districtsBy(input: MultiParamInput!): [District!]
}

type District {
  YEAR: String!
  PROVINCE: String!
  REGION: String!
  DISTRICT: String!
  REGION_ID: ID!
  PROVINCE_ID: ID!
  DISTRICT_ID: ID!
  POP_ZONE: String!
  ECON_SCORE: String!
  FOREST_SCORE: String!
  AIR_SCORE: String!
  TEMP_SCORE: String!
  ENVR_SCORE: String!
  # COLOR: String!
}

# could be better to switch this to year/region_id/province_id/pop_zone
# this layout would be safer to use and extremely powerful! pretty much every query handled for your app in this one query!!
# Declare custom scalar type Nullable, and create union of input types for MultiParaInput

# union StringOrNull = String | Nullable

# scalar Nullable
# Making
input MultiParamInput {
  # YEAR: StringOrNull!
  YEAR: String
  # REGION: String
  REGION_ID: ID
  # PROVINCE: String
  PROVINCE_ID: ID
  POP_ZONE: String
}

# I wonder if its worth creating a multilevel type that have a bunch a associated properties... like the distrcit has a region of type Region.. and province of type province.. when then each contain all the districts in their respected region/province

# type Query {
#   books: [Book]
#   booksByRating(minRating: Int!): [Book]
# }

# type Mutation {
#   addNewBook(name: String!, author: String!, rating: String!): Book
#   deleteBookWithId(bookId: ID!): Book
#   editBookWithId(bookId: ID!, book: BookInput!): Book
# }

# type Book {
#   inStock: Boolean
#   bookId: ID
#   name: String!
#   author: String!
#   rating: String!
# }

# input BookInput {
#   name: String!
#   author: String!
#   rating: String!
# }
